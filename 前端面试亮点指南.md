# 🚀 前端面试项目亮点指南

> 面试官最爱听的不是"我做了什么"，而是"我为什么这样做"和"带来了什么价值"

---

## 目录

1. [虚拟列表优化](#1-虚拟列表优化---只渲染看得见的)
2. [请求防抖与节流](#2-请求防抖与节流---别让服务器累坏了)
3. [骨架屏加载](#3-骨架屏加载---让等待不再焦虑)
4. [状态管理优化](#4-状态管理优化---数据的交通指挥员)
5. [图片懒加载](#5-图片懒加载---按需配送的快递员)
6. [组件设计模式](#6-组件设计模式---乐高积木思维)
7. [错误边界与监控](#7-错误边界与监控---给代码装个行车记录仪)
8. [离线缓存方案](#8-离线缓存方案---给网页装个冰箱)

---

## 1. 虚拟列表优化 - 只渲染看得见的

### 🎯 生活化比喻

想象你在刷抖音，手机里有 10000 个视频。如果一次性把所有视频都加载出来，手机不得爆炸？

**聪明的做法**：只加载你当前看到的那几个视频，往下滑的时候，上面的视频"回收"掉，下面的视频"预加载"上来。

这就是**虚拟列表**的核心思想：**只渲染可视区域的内容**。

### 📊 效果对比

| 方案 | 10000条数据 DOM 节点数 | 内存占用 | 渲染时间 |
|------|----------------------|---------|---------|
| 传统列表 | 10000+ | 200MB+ | 3-5秒 |
| 虚拟列表 | 20-30 | 10MB | 毫秒级 |

### 💻 代码示例

```javascript
// 虚拟列表的核心逻辑
const VirtualList = {
  data() {
    return {
      allData: [],          // 全部数据（比如10000条）
      visibleData: [],      // 可见数据（只有20条左右）
      itemHeight: 50,       // 每个元素高度
      visibleCount: 20,     // 可见数量
      startIndex: 0,        // 开始索引
      scrollTop: 0          // 滚动位置
    }
  },
  
  computed: {
    // 容器总高度 = 数据总数 × 每项高度
    totalHeight() {
      return this.allData.length * this.itemHeight
    },
    
    // 可见区域的偏移量
    offsetY() {
      return this.startIndex * this.itemHeight
    }
  },
  
  methods: {
    handleScroll(e) {
      const scrollTop = e.target.scrollTop
      // 计算当前应该从第几个开始显示
      this.startIndex = Math.floor(scrollTop / this.itemHeight)
      // 只截取需要显示的数据
      this.visibleData = this.allData.slice(
        this.startIndex, 
        this.startIndex + this.visibleCount
      )
    }
  }
}
```

### 🎤 面试话术

> "在我们的项目中，有一个文档列表页面需要展示上万条数据。最初使用普通渲染，页面卡顿严重，FPS 只有 10 左右。
> 
> 我引入了虚拟列表方案，**核心思想是只渲染可视区域内的 DOM 节点**。通过监听滚动事件，动态计算当前应该显示哪些数据，实现了 DOM 节点数从 10000+ 降低到 20 个左右。
> 
> 最终效果：页面 FPS 稳定在 60，内存占用减少 90%，用户反馈流畅度明显提升。"

---

## 2. 请求防抖与节流 - 别让服务器累坏了

### 🎯 生活化比喻

**防抖(Debounce)**：就像电梯关门。电梯不会你按一下关门就关，而是等最后一个人进来后，等待几秒没人了，才关门。

**节流(Throttle)**：就像游戏里的技能冷却。按再多次，技能也要等 CD 好了才能放。

### 📊 使用场景对比

| 场景 | 用防抖 | 用节流 |
|------|-------|-------|
| 搜索框输入 | ✅ 等用户停止输入再搜索 | |
| 窗口 resize | | ✅ 每隔一段时间计算一次 |
| 按钮提交 | ✅ 防止重复点击 | |
| 滚动加载 | | ✅ 滚动时定期检查位置 |
| 输入框实时保存 | ✅ 停止输入后保存 | |

### 💻 代码示例

```javascript
// 防抖：等用户停下来再执行
function debounce(fn, delay = 300) {
  let timer = null
  return function(...args) {
    // 每次调用都清除上一次的定时器
    clearTimeout(timer)
    // 重新设置定时器
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 使用示例：搜索框
const searchInput = document.querySelector('#search')
searchInput.addEventListener('input', debounce((e) => {
  // 用户停止输入 300ms 后才发请求
  fetchSearchResults(e.target.value)
}, 300))


// 节流：固定频率执行
function throttle(fn, interval = 100) {
  let lastTime = 0
  return function(...args) {
    const now = Date.now()
    // 距离上次执行超过间隔才执行
    if (now - lastTime >= interval) {
      lastTime = now
      fn.apply(this, args)
    }
  }
}

// 使用示例：滚动监听
window.addEventListener('scroll', throttle(() => {
  // 每 100ms 最多执行一次
  checkScrollPosition()
}, 100))
```

### 🎤 面试话术

> "在项目的搜索功能中，最初每次输入都会触发 API 请求，用户输入 '前端开发' 四个字就触发了 4 次请求，服务器压力大，用户体验也差。
> 
> 我引入了**防抖机制**，等用户停止输入 300ms 后才发起请求。同时对滚动加载使用**节流**，确保滚动事件不会过于频繁触发。
> 
> 效果：API 请求量减少 80%，服务器压力明显降低，页面也更流畅了。"

---

## 3. 骨架屏加载 - 让等待不再焦虑

### 🎯 生活化比喻

去餐厅吃饭，服务员说"请稍等"然后消失了，你会焦虑；但如果服务员先上一杯茶、摆好餐具，告诉你"菜正在做"，你就安心多了。

**骨架屏**就是那杯茶和餐具 —— 让用户知道"内容正在来的路上"。

### 📊 用户体验对比

| 加载方式 | 用户感知 | 跳出率 |
|---------|---------|-------|
| 白屏等待 | "是不是挂了？" | 高 |
| Loading 菊花 | "好无聊..." | 中 |
| 骨架屏 | "马上就好" | 低 |

### 💻 代码示例

```vue
<template>
  <div class="page">
    <!-- 骨架屏：数据未加载时显示 -->
    <div v-if="loading" class="skeleton">
      <div class="skeleton-avatar"></div>
      <div class="skeleton-content">
        <div class="skeleton-title"></div>
        <div class="skeleton-text"></div>
        <div class="skeleton-text short"></div>
      </div>
    </div>
    
    <!-- 真实内容：数据加载完成后显示 -->
    <div v-else class="real-content">
      <img :src="user.avatar" class="avatar" />
      <div class="content">
        <h3>{{ user.name }}</h3>
        <p>{{ user.bio }}</p>
      </div>
    </div>
  </div>
</template>

<style>
/* 骨架屏样式 - 关键是动画效果 */
.skeleton-avatar,
.skeleton-title,
.skeleton-text {
  background: linear-gradient(
    90deg,
    #f0f0f0 25%,
    #e0e0e0 50%,
    #f0f0f0 75%
  );
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
}

@keyframes shimmer {
  0% { background-position: 200% 0; }
  100% { background-position: -200% 0; }
}

.skeleton-avatar {
  width: 60px;
  height: 60px;
  border-radius: 50%;
}

.skeleton-title {
  width: 150px;
  height: 20px;
  margin-bottom: 10px;
}

.skeleton-text {
  width: 100%;
  height: 14px;
  margin-bottom: 8px;
}

.skeleton-text.short {
  width: 60%;
}
</style>
```

### 🎤 面试话术

> "在我们的移动端项目中，首屏加载需要 2-3 秒。最初使用 Loading 动画，用户反馈说'感觉很慢'。
> 
> 我引入了**骨架屏方案**，在数据请求期间先展示页面的灰色轮廓，给用户'内容即将呈现'的预期。还加了微光动画效果，让等待过程更自然。
> 
> 根据埋点数据，同样的加载时间，骨架屏方案下用户的**感知等待时间减少 40%**，页面跳出率下降 15%。"

---

## 4. 状态管理优化 - 数据的交通指挥员

### 🎯 生活化比喻

想象一个大家庭，10 个人住一起。

**没有状态管理**：每个人想知道"今晚吃什么"，都要挨个问一遍，或者大喊大叫，乱成一锅粥。

**有状态管理**：在客厅挂个公告板，"今晚吃火锅"写上去，所有人看公告板就行，改动也在公告板改，自动通知所有人。

### 📊 问题与方案

```
❌ 问题：父子孙组件层层传递 props，"props drilling"地狱

    App
     └── Header
          └── UserPanel
               └── UserAvatar  ← 需要用户信息，但要从 App 一路传下来

✅ 方案：状态管理集中存储，哪里需要哪里取

    [Vuex/Pinia Store]
         ↓
       直接获取
         ↓
    UserAvatar 组件
```

### 💻 代码示例

```javascript
// store/modules/user.js - Vuex 模块化设计
export default {
  namespaced: true,
  
  state: () => ({
    userInfo: null,
    token: localStorage.getItem('token') || '',
    permissions: []
  }),
  
  getters: {
    // 派生状态：判断是否登录
    isLoggedIn: state => !!state.token,
    // 派生状态：判断是否管理员
    isAdmin: state => state.permissions.includes('admin')
  },
  
  mutations: {
    SET_USER_INFO(state, info) {
      state.userInfo = info
    },
    SET_TOKEN(state, token) {
      state.token = token
      localStorage.setItem('token', token)
    },
    CLEAR_USER(state) {
      state.userInfo = null
      state.token = ''
      state.permissions = []
      localStorage.removeItem('token')
    }
  },
  
  actions: {
    // 异步操作：登录
    async login({ commit }, credentials) {
      try {
        const { data } = await api.login(credentials)
        commit('SET_TOKEN', data.token)
        commit('SET_USER_INFO', data.user)
        return data
      } catch (error) {
        commit('CLEAR_USER')
        throw error
      }
    },
    
    // 异步操作：获取用户信息（带缓存判断）
    async fetchUserInfo({ commit, state }) {
      // 已有数据就不重复请求
      if (state.userInfo) return state.userInfo
      
      const { data } = await api.getUserInfo()
      commit('SET_USER_INFO', data)
      return data
    }
  }
}

// 组件中使用
import { mapState, mapGetters, mapActions } from 'vuex'

export default {
  computed: {
    ...mapState('user', ['userInfo']),
    ...mapGetters('user', ['isLoggedIn', 'isAdmin'])
  },
  methods: {
    ...mapActions('user', ['login', 'fetchUserInfo'])
  }
}
```

### 🎤 面试话术

> "在项目中，用户信息需要在十几个组件中使用，最初通过 props 层层传递，代码维护困难，新人很难理清数据流向。
> 
> 我重构了状态管理，采用 **Vuex 模块化设计**：
> 1. 按业务划分 modules（user、product、order）
> 2. 用 getters 处理派生状态，避免重复计算
> 3. 异步操作封装在 actions，加入缓存判断减少请求
> 
> 重构后，组件代码减少 30%，数据流向清晰可追踪，新人上手时间缩短一半。"

---

## 5. 图片懒加载 - 按需配送的快递员

### 🎯 生活化比喻

你在淘宝买了 100 件商品，如果快递员一次性把 100 个包裹都送到你家门口，你家门都堵死了。

**聪明的做法**：你需要哪个，快递员就送哪个。你打开衣柜要放衣服了，衣服包裹送到；你打开冰箱要放吃的了，食品包裹送到。

**图片懒加载**就是这个思路：只加载用户能看到的图片。

### 📊 性能对比

假设页面有 50 张图片，每张 200KB：

| 方案 | 首次加载数据量 | 首屏时间 | 流量消耗 |
|------|--------------|---------|---------|
| 全部加载 | 10MB | 5秒+ | 10MB |
| 懒加载 | 1MB（5张） | 1秒 | 按需消耗 |

### 💻 代码示例

```javascript
// 方案一：Intersection Observer（现代浏览器推荐）
class ImageLazyLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          // 当图片进入可视区域
          if (entry.isIntersecting) {
            const img = entry.target
            // 将 data-src 的值赋给 src，触发真正的图片加载
            img.src = img.dataset.src
            // 加载后取消观察
            this.observer.unobserve(img)
          }
        })
      },
      {
        // 提前 100px 开始加载，用户体验更好
        rootMargin: '100px'
      }
    )
  }
  
  observe(img) {
    this.observer.observe(img)
  }
}

// 使用方式
const loader = new ImageLazyLoader()
document.querySelectorAll('img[data-src]').forEach(img => {
  loader.observe(img)
})


// 方案二：Vue 自定义指令
Vue.directive('lazy', {
  inserted(el, binding) {
    const observer = new IntersectionObserver(([entry]) => {
      if (entry.isIntersecting) {
        el.src = binding.value
        observer.disconnect()
      }
    })
    observer.observe(el)
  }
})

// 模板中使用
// <img v-lazy="imageUrl" />
```

```html
<!-- HTML 结构 -->
<img 
  data-src="real-image.jpg" 
  src="placeholder.jpg"  
  alt="图片描述"
/>
<!-- 
  src: 占位图（很小，比如 1KB 的灰色图）
  data-src: 真正的图片地址（等进入视口再加载）
-->
```

### 🎤 面试话术

> "在我们的图片列表页面，有大量商品图片。最初所有图片同时加载，首屏时间长达 5 秒，流量浪费严重。
> 
> 我实现了**图片懒加载**方案：
> 1. 使用 `Intersection Observer API` 监听图片是否进入可视区域
> 2. 设置 `rootMargin: 100px` 提前加载，避免用户看到空白
> 3. 封装成 Vue 指令，一行代码即可使用
> 
> 效果：首屏加载时间从 5 秒降到 1.2 秒，流量节省 70%+，用户 LCP 指标明显改善。"

---

## 6. 组件设计模式 - 乐高积木思维

### 🎯 生活化比喻

**乐高积木**为什么好玩？因为每块积木都是标准的，可以任意组合。你可以用相同的积木搭出汽车、房子、飞机。

**好的组件设计**也是这样：
- 每个组件职责单一（一块积木只有一种形状）
- 组件可以任意组合（积木可以拼起来）
- 改一个不影响其他（换一块积木不会导致整个作品塌掉）

### 📊 组件设计原则

```
✅ 好的组件设计

┌─────────────────────────────────────┐
│           页面 (Page)               │
├─────────────────────────────────────┤
│  ┌─────────┐  ┌─────────────────┐   │
│  │ 搜索框  │  │    筛选器        │   │  ← 业务组件
│  └─────────┘  └─────────────────┘   │
├─────────────────────────────────────┤
│  ┌─────────────────────────────┐    │
│  │        商品列表             │    │  ← 容器组件
│  │  ┌─────┐ ┌─────┐ ┌─────┐   │    │
│  │  │商品卡│ │商品卡│ │商品卡│   │    │  ← 展示组件
│  │  └─────┘ └─────┘ └─────┘   │    │
│  └─────────────────────────────┘    │
└─────────────────────────────────────┘

每个组件：
- 单一职责：商品卡只管展示商品
- Props In：通过 props 接收数据
- Events Out：通过事件向外通信
- 不操作外部状态
```

### 💻 代码示例

```vue
<!-- 基础组件：Button.vue -->
<template>
  <button 
    :class="['btn', `btn--${type}`, `btn--${size}`]"
    :disabled="disabled || loading"
    @click="handleClick"
  >
    <span v-if="loading" class="btn__loading">
      <LoadingIcon />
    </span>
    <slot>{{ text }}</slot>
  </button>
</template>

<script>
export default {
  name: 'BaseButton',
  props: {
    type: {
      type: String,
      default: 'default',
      validator: v => ['default', 'primary', 'danger'].includes(v)
    },
    size: {
      type: String,
      default: 'medium',
      validator: v => ['small', 'medium', 'large'].includes(v)
    },
    disabled: Boolean,
    loading: Boolean,
    text: String
  },
  methods: {
    handleClick(e) {
      if (!this.loading && !this.disabled) {
        this.$emit('click', e)
      }
    }
  }
}
</script>


<!-- 业务组件：ProductCard.vue（组合基础组件） -->
<template>
  <div class="product-card">
    <img :src="product.image" :alt="product.name" />
    <h3>{{ product.name }}</h3>
    <p class="price">¥{{ product.price }}</p>
    
    <!-- 使用基础 Button 组件 -->
    <BaseButton 
      type="primary"
      :loading="adding"
      @click="handleAddToCart"
    >
      加入购物车
    </BaseButton>
  </div>
</template>

<script>
export default {
  name: 'ProductCard',
  props: {
    product: {
      type: Object,
      required: true
    }
  },
  data: () => ({
    adding: false
  }),
  methods: {
    async handleAddToCart() {
      this.adding = true
      try {
        await this.$store.dispatch('cart/addItem', this.product)
        this.$emit('added', this.product)
      } finally {
        this.adding = false
      }
    }
  }
}
</script>
```

### 🎤 面试话术

> "在项目中，我主导了组件库的架构设计，采用**分层组件**的思想：
> 
> 1. **基础组件层**：Button、Input、Modal 等，不含业务逻辑，只负责 UI 和交互
> 2. **业务组件层**：ProductCard、UserPanel 等，组合基础组件，封装业务逻辑
> 3. **页面容器层**：负责数据获取和状态管理，向下分发数据
> 
> 同时建立了组件开发规范：
> - Props 必须声明类型和默认值
> - 使用 $emit 向上通信，禁止直接修改父组件状态
> - 组件命名使用 PascalCase，文件夹按功能组织
> 
> 效果：组件复用率提升 60%，新页面开发效率提高 40%。"

---

## 7. 错误边界与监控 - 给代码装个行车记录仪

### 🎯 生活化比喻

开车为什么要装行车记录仪？因为出了事故，你得知道是怎么发生的，才能判定责任、避免下次再犯。

代码也一样。线上出 Bug 了，用户说"页面白屏了"，你得知道：
- 什么时候出的错？
- 在哪个页面？
- 用户做了什么操作？
- 具体报了什么错？

**错误监控**就是代码的行车记录仪。

### 📊 监控维度

```
┌─────────────────────────────────────────┐
│            前端错误监控体系              │
├─────────────────────────────────────────┤
│                                         │
│  JS 运行时错误    →  window.onerror     │
│  Promise 异常     →  unhandledrejection │
│  资源加载失败     →  error 事件捕获      │
│  接口请求异常     →  axios 拦截器       │
│  Vue 组件错误     →  errorHandler       │
│  性能数据        →  Performance API     │
│                                         │
└─────────────────────────────────────────┘
```

### 💻 代码示例

```javascript
// errorMonitor.js - 错误监控核心代码

class ErrorMonitor {
  constructor(options = {}) {
    this.reportUrl = options.reportUrl
    this.appId = options.appId
    this.init()
  }

  init() {
    // 1. 捕获 JS 运行时错误
    window.onerror = (message, source, line, column, error) => {
      this.report({
        type: 'js_error',
        message,
        source,
        line,
        column,
        stack: error?.stack
      })
      return true // 阻止控制台报错
    }

    // 2. 捕获 Promise 未处理异常
    window.addEventListener('unhandledrejection', (event) => {
      this.report({
        type: 'promise_error',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack
      })
    })

    // 3. 捕获资源加载错误（图片、脚本、样式）
    window.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.report({
          type: 'resource_error',
          tagName: event.target.tagName,
          src: event.target.src || event.target.href
        })
      }
    }, true) // 注意：必须用捕获模式

    // 4. 捕获接口错误（axios 拦截器）
    this.setupAxiosInterceptor()
  }

  setupAxiosInterceptor() {
    axios.interceptors.response.use(
      response => response,
      error => {
        this.report({
          type: 'api_error',
          url: error.config?.url,
          method: error.config?.method,
          status: error.response?.status,
          message: error.message
        })
        return Promise.reject(error)
      }
    )
  }

  report(errorInfo) {
    const data = {
      ...errorInfo,
      appId: this.appId,
      url: location.href,
      userAgent: navigator.userAgent,
      timestamp: Date.now(),
      // 用户标识（如果有）
      userId: localStorage.getItem('userId')
    }

    // 使用 sendBeacon 确保页面关闭时也能发送
    if (navigator.sendBeacon) {
      navigator.sendBeacon(this.reportUrl, JSON.stringify(data))
    } else {
      // 降级方案
      fetch(this.reportUrl, {
        method: 'POST',
        body: JSON.stringify(data),
        keepalive: true
      })
    }
  }
}

// Vue 项目中初始化
const monitor = new ErrorMonitor({
  reportUrl: '/api/error/report',
  appId: 'my-app'
})

// Vue 错误处理
Vue.config.errorHandler = (err, vm, info) => {
  monitor.report({
    type: 'vue_error',
    message: err.message,
    stack: err.stack,
    component: vm?.$options?.name,
    info // 生命周期钩子信息
  })
}
```

### 🎤 面试话术

> "在项目中，我搭建了**前端错误监控系统**，主要解决'用户反馈问题但无法复现'的痛点。
> 
> 技术方案：
> 1. 使用 `window.onerror` 捕获 JS 错误
> 2. 使用 `unhandledrejection` 捕获 Promise 异常
> 3. 使用事件捕获模式监听资源加载失败
> 4. Axios 拦截器记录接口异常
> 5. Vue 的 `errorHandler` 捕获组件错误
> 
> 同时记录用户环境信息（URL、UA、用户 ID），使用 `sendBeacon` 保证数据不丢失。
> 
> 上线后，问题定位时间从'几天'缩短到'几分钟'，故障响应效率提升 80%。"

---

## 8. 离线缓存方案 - 给网页装个冰箱

### 🎯 生活化比喻

为什么家里要有冰箱？因为你不可能每次饿了都去超市买菜。把常用的食材存在冰箱里，随时可以拿来用。

**离线缓存**就是网页的冰箱：
- 把用过的资源存起来
- 下次访问直接从"冰箱"拿，不用再去"超市"（服务器）
- 甚至断网了也能用

### 📊 缓存策略对比

| 策略 | 特点 | 适用场景 |
|------|------|---------|
| Cache First | 优先缓存，缓存没有才请求 | 静态资源（JS/CSS/图片） |
| Network First | 优先网络，网络失败用缓存 | API 数据（需要新鲜） |
| Stale While Revalidate | 先返回缓存，同时更新 | 不那么敏感的数据 |

### 💻 代码示例

```javascript
// service-worker.js

const CACHE_NAME = 'my-app-v1'
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/css/style.css',
  '/js/app.js',
  '/images/logo.png'
]

// 安装 SW 时，预缓存静态资源
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(STATIC_ASSETS))
  )
})

// 拦截请求
self.addEventListener('fetch', (event) => {
  const { request } = event
  
  // 静态资源：Cache First
  if (request.destination === 'style' || 
      request.destination === 'script' ||
      request.destination === 'image') {
    event.respondWith(cacheFirst(request))
  }
  // API 请求：Network First
  else if (request.url.includes('/api/')) {
    event.respondWith(networkFirst(request))
  }
})

// Cache First 策略
async function cacheFirst(request) {
  const cached = await caches.match(request)
  if (cached) {
    return cached // 有缓存直接返回
  }
  // 没缓存就请求，并存入缓存
  const response = await fetch(request)
  const cache = await caches.open(CACHE_NAME)
  cache.put(request, response.clone())
  return response
}

// Network First 策略
async function networkFirst(request) {
  try {
    // 优先请求网络
    const response = await fetch(request)
    // 请求成功，更新缓存
    const cache = await caches.open(CACHE_NAME)
    cache.put(request, response.clone())
    return response
  } catch (error) {
    // 网络失败，使用缓存
    const cached = await caches.match(request)
    if (cached) {
      return cached
    }
    // 连缓存都没有，返回离线页面
    return caches.match('/offline.html')
  }
}


// 主应用中注册 Service Worker
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(reg => console.log('SW 注册成功'))
      .catch(err => console.log('SW 注册失败', err))
  })
}
```

### 🎤 面试话术

> "针对我们的移动端应用在弱网环境下体验差的问题，我实现了 **Service Worker 离线缓存方案**：
> 
> 1. **静态资源**（JS/CSS/图片）采用 Cache First 策略，优先使用缓存
> 2. **API 数据**采用 Network First 策略，保证数据新鲜度
> 3. 预缓存核心资源，确保首屏可离线访问
> 4. 设计了离线降级页面，网络完全不可用时给用户友好提示
> 
> 上线效果：
> - 二次访问加载速度提升 70%
> - 弱网环境下可正常使用核心功能
> - 用户满意度明显提升，差评率下降 25%"

---

## 🎁 面试加分技巧

### 1. STAR 法则回答问题

- **S (Situation)**：当时是什么情况/背景？
- **T (Task)**：你要解决什么问题？
- **A (Action)**：你具体做了什么？
- **R (Result)**：带来了什么效果？（最好有数据）

### 2. 准备数据支撑

> ❌ "优化后快了很多"
> 
> ✅ "首屏时间从 3.2 秒降到 1.1 秒，提升 65%"

### 3. 展示思考深度

面试官问："你怎么实现的图片懒加载？"

> ❌ 只说实现方式
> 
> ✅ 还要说：
> - 为什么选 Intersection Observer 而不是 scroll 事件？
> - 有什么兼容性问题？怎么处理的？
> - 如何处理图片加载失败？
> - 是否考虑了预加载提升体验？

### 4. 表达你的"技术品味"

> "我在实现这个功能时，不只是完成需求，还考虑了可维护性。比如我把懒加载封装成了指令，其他同事一行代码就能用，不需要了解底层实现。"

---

## 📚 扩展阅读

- [Web Vitals - Google 性能指标](https://web.dev/vitals/)
- [Vue 性能优化指南](https://vuejs.org/guide/best-practices/performance.html)
- [Service Worker 入门](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)

---

> 💡 **记住**：面试不是背答案，而是展示你的思考过程和解决问题的能力。准备好这些亮点，然后用自己的话讲出来！

祝面试顺利！🎉



